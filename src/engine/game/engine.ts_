/**
 * LittleJS - The Tiny Fast JavaScript Game Engine
 * MIT License - Copyright 2021 Frank Force
 *
 * Engine Features
 * - Object oriented system with base class engine object
 * - Base class object handles update, physics, collision, rendering, etc
 * - Engine helper classes and functions like Vector2, Color, and Timer
 * - Super fast rendering system for tile sheets
 * - Sound effects audio with zzfx and music with zzfxm
 * - Input processing system with gamepad and touchscreen support
 * - Tile layer rendering and collision system
 * - Particle effect system
 * - Medal system tracks and displays achievements
 * - Post processing effects
 * - Call engineInit() to start it up!
 * @namespace Engine
 */

/** Frames per second to update
 *  @type {number}
 *  @default
 *  @memberof Engine */
const frameRate = 60;

/** How many seconds each frame lasts, engine uses a fixed time step
 *  @type {number}
 *  @default 1/60
 *  @memberof Engine */
const timeDelta = 1 / frameRate;

/** Array containing all engine objects
 *  @type {Array<EngineObject>}
 *  @memberof Engine */
const engineObjects = [];

/** Current update frame, used to calculate time
 *  @type {number}
 *  @memberof Engine */
let frame = 0;

/** Current engine time since start in seconds
 *  @type {number}
 *  @memberof Engine */
let time = 0;

/** Actual clock time since start in seconds (not affected by pause or frame rate clamping)
 *  @type {number}
 *  @memberof Engine */
let timeReal = 0;

/** Is the game paused? Causes time and objects to not be updated
 *  @type {boolean}
 *  @default false
 *  @memberof Engine */
let paused = false;

/** Get if game is paused
 *  @return {boolean}
 *  @memberof Engine */
function getPaused() {
  return paused;
}

/** Set if game is paused
 *  @param {boolean} [isPaused]
 *  @memberof Engine */
function setPaused(isPaused = true) {
  paused = isPaused;
}

// Frame time tracking
let frameTimeLastMS = 0,
  frameTimeBufferMS = 0;

/** Startup LittleJS engine with your callback functions
 *  @param {Function|function():Promise} gameInit - Called once after the engine starts up, can be async for loading
 *  @param {Function} gameUpdate - Called every frame before objects are updated (60fps), use for game logic
 *  @param {Function} gameUpdatePost - Called after physics and objects are updated, even when paused, use for UI updates
 *  @param {Function} gameRender - Called before objects are rendered, use for drawing backgrounds/world elements
 *  @param {Function} gameRenderPost - Called after objects are rendered, use for drawing UI/overlays
 *  @param {Array<string>} [imageSources=[]] - List of image file paths to preload (e.g., ['player.png', 'tiles.png'])
 *  @param {HTMLElement} [rootElement] - Root DOM element to attach canvas to, defaults to document.body
 *  @example
 *  // Basic engine startup
 *  engineInit(
 *    () => { LOG('Game initialized!'); },  // gameInit
 *    () => { updateGameLogic(); },         // gameUpdate
 *    () => { updateUI(); },                // gameUpdatePost
 *    () => { drawBackground(); },          // gameRender
 *    () => { drawHUD(); },                 // gameRenderPost
 *    ['tiles.png', 'tilesLevel.png']       // images to load
 *  );
 *  @memberof Engine */
async function engineInit(
  gameInit,
  gameUpdate,
  gameUpdatePost,
  gameRender,
  gameRenderPost,
  imageSources = [],
  rootElement = document.body,
) {
  // allow passing in empty functions
  gameInit ||= () => {};
  gameUpdate ||= () => {};
  gameUpdatePost ||= () => {};
  gameRender ||= () => {};
  gameRenderPost ||= () => {};

  // Called automatically by engine to setup render system
  function enginePreRender() {
    // save canvas size
    mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);

    // disable smoothing for pixel art
    overlayContext.imageSmoothingEnabled = mainContext.imageSmoothingEnabled =
      !tilesPixelated;

    // setup gl rendering if enabled
    glPreRender();
  }

  // internal update loop for engine
  function engineUpdate(frameTimeMS = 0) {
    // update time keeping
    const frameTimeDeltaMS = frameTimeMS - frameTimeLastMS;
    frameTimeLastMS = frameTimeMS;
    timeReal += frameTimeDeltaMS / 1e3;
    frameTimeBufferMS += paused ? 0 : frameTimeDeltaMS;
    frameTimeBufferMS = min(frameTimeBufferMS, 50); // clamp min framerate

    let wasUpdated = false;
    if (paused) {
      // update everything except the game and objects
      wasUpdated = true;
      updateCanvas();
      inputUpdate();

      // update object transforms even when paused
      for (const o of engineObjects) o.parent || o.updateTransforms();

      // do post update
      gameUpdatePost();
      inputUpdatePost();
    } else {
      // apply time delta smoothing, improves smoothness of framerate in some browsers
      let deltaSmooth = 0;
      if (frameTimeBufferMS < 0 && frameTimeBufferMS > -9) {
        // force at least one update each frame since it is waiting for refresh
        deltaSmooth = frameTimeBufferMS;
        frameTimeBufferMS = 0;
      }

      // update multiple frames if necessary in case of slow framerate
      for (; frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / frameRate) {
        // increment frame and update time
        time = frame++ / frameRate;

        // update game and objects
        wasUpdated = true;
        updateCanvas();
        inputUpdate();
        gameUpdate();

        // do post update
        gameUpdatePost();
        inputUpdatePost();
      }

      // add the time smoothing back in
      frameTimeBufferMS += deltaSmooth;
    }

    renderFrame();
    requestAnimationFrame(engineUpdate);

    function renderFrame() {
      if (headlessMode) return;

      // canvas must be updated before rendering
      if (!wasUpdated) updateCanvas();

      // render sort then render while removing destroyed objects
      enginePreRender();
      gameRender();
      engineObjects.sort((a, b) => a.renderOrder - b.renderOrder);
      for (const o of engineObjects) o.destroyed || o.render();
      gameRenderPost();
      touchGamepadRender();
      glFlush();

      drawCount = 0;
    }
  }

  function updateCanvas() {
    if (headlessMode) return;

    if (canvasFixedSize.x) {
      // clear canvas and set fixed size
      mainCanvas.width = canvasFixedSize.x;
      mainCanvas.height = canvasFixedSize.y;

      // fit to window by adding space on top or bottom if necessary
      const aspect = innerWidth / innerHeight;
      const fixedAspect = mainCanvas.width / mainCanvas.height;
      (glCanvas || mainCanvas).style.width =
        mainCanvas.style.width =
        overlayCanvas.style.width =
          aspect < fixedAspect ? '100%' : '';
      (glCanvas || mainCanvas).style.height =
        mainCanvas.style.height =
        overlayCanvas.style.height =
          aspect < fixedAspect ? '' : '100%';
    } else {
      // clear canvas and set size to same as window
      mainCanvas.width = min(innerWidth, canvasMaxSize.x);
      mainCanvas.height = min(innerHeight, canvasMaxSize.y);
    }

    // apply the clear color to main canvas
    if (canvasClearColor.a > 0) {
      mainContext.fillStyle = canvasClearColor.toString();
      mainContext.fillRect(0, 0, mainCanvasSize.x, mainCanvasSize.y);
      mainContext.fillStyle = BLACK.toString();
    }

    // clear overlay canvas and set size
    overlayCanvas.width = mainCanvas.width;
    overlayCanvas.height = mainCanvas.height;

    // save canvas size
    mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);

    // set default line join and cap
    const lineJoin = 'round',
      lineCap = 'round';
    mainContext.lineJoin = overlayContext.lineJoin = lineJoin;
    mainContext.lineCap = overlayContext.lineCap = lineCap;
  }

  // wait for gameInit to load
  async function startEngine() {
    await gameInit();
    engineUpdate();
  }
  if (headlessMode) return startEngine();

  // setup html
  const styleRoot =
    'margin:0;' + // fill the window
    'overflow:hidden;' + // no scroll bars
    'background:#000;' + // set background color
    'user-select:none;' + // prevent hold to select
    '-webkit-user-select:none;' + // compatibility for ios
    'touch-action:none;' + // prevent mobile pinch to resize
    '-webkit-touch-callout:none'; // compatibility for ios
  rootElement.style.cssText = styleRoot;
  drawCanvas = mainCanvas = document.createElement('canvas');
  rootElement.appendChild(mainCanvas);
  drawContext = mainContext = mainCanvas.getContext('2d');

  // init stuff and start engine
  inputInit();
  audioInit();
  glInit();

  // create overlay canvas for hud to appear above gl canvas
  overlayCanvas = document.createElement('canvas');
  rootElement.appendChild(overlayCanvas);
  overlayContext = overlayCanvas.getContext('2d');

  // set canvases
  const styleCanvas =
    'position:absolute;' + // allow canvases to overlap
    'top:50%;left:50%;transform:translate(-50%,-50%)'; // center on screen
  mainCanvas.style.cssText = overlayCanvas.style.cssText = styleCanvas;
  if (glCanvas) glCanvas.style.cssText = styleCanvas;
  setCanvasPixelated(canvasPixelated);
  setOverlayCanvasPixelated(overlayCanvasPixelated);
  updateCanvas();
  glPreRender();

  // create offscreen canvas for image processing
  workCanvas = new OffscreenCanvas(256, 256);
  workContext = workCanvas.getContext('2d', { willReadFrequently: true });

  // create promises for loading images
  const promises = imageSources.map(
    (src, textureIndex) =>
      new Promise((resolve) => {
        const image = new Image();
        image.onerror = image.onload = () => {
          const textureInfo = new TextureInfo(image);
          textureInfo.createWebGLTexture();
          textureInfos[textureIndex] = textureInfo;
          resolve();
        };
        image.crossOrigin = 'anonymous';
        image.src = src;
      }),
  );

  if (!imageSources.length) {
    // no images to load
    promises.push(
      new Promise((resolve) => {
        const textureInfo = new TextureInfo(new Image());
        textureInfos[0] = textureInfo;
        textureInfo.createWebGLTexture();
        resolve();
      }),
    );
  }

  // wait for all the promises to finish
  await Promise.all(promises);
  return startEngine();
}
